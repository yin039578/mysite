# Task 【Giver】新增FB連結回傳欄位_2025/5月
[Jira](https://104corp.atlassian.net/browse/GIVERFARM-1556)

## 需求&規則



## 作業流程
 
## 流程
### 主要 流程一
### 主要 流程二
 
## 開發範疇
### 後端
#### 後端task1
#### 後端task2

### 前端
#### 前端task1
#### 前端task2

### 上版注意

### 驗收注意

### 延伸議題

# prompt
請幫我翻寫Java的API到python專案
1. 翻寫getFavoriteJob, updateJobFavorite
2. 程式放在python專案的api_job模組內
3. 邏輯與基本原則不變，但是語法與邏輯可以優化，命名方式以python慣例為主
4. 優先參考api_job模組內現成函式運作方式作為改寫參考
5. 先幫我逐行爬梳並簡化說明他做的事情有哪些，並說明改寫計劃與我討論

======================== chat

Used 1 reference
我將快速檢查專案中是否已有類似的 external API wrapper 實作風格（components.e104.api 目錄下），以便提出具體的檔案/函式樣板與命名建議；接著回報檢查結果與完整改寫計畫。這會是只做 read-only 的搜尋。

Searched text for components.e104.api, 100 results
我將搜尋專案中是否已有 job fit 的處理（jobFitHandler、job_fit、JobFitModel 等），以及現有 components/e104/api 下的 wrapper 命名慣例，來驗證你的三點需求是否可行並提出實作細節與風險。這是只做 read-only 的搜尋。

Searched text for JobFitModel|job_fit|jobFitHandler|getJobFit|get_job_fit|JobFit, 200 results
Searched text for jobFit|job_fit|JobFitHandler|get_job_fit|JobFit, 200 results
我會再確認 Python 專案中是否已經有 job fit 的 handler 或 apply API 的 wrapper，這樣可以決定要不要新增或直接呼叫既有服務。我要做兩個快速、只讀的搜尋：1) 搜尋 job fit 相關符號 2) 搜尋 apply API wrapper 是否存在。結果會告訴我們是否需要新增文件與功能。

Searched text for jobfit|JobFit|get_job_fit|job_fit_handler|JobFitModel, 200 results
我會就你要求的三點（把 Java 的 getJobFit 納入、建立 apply API wrapper、外層使用 Python 回應但內層資料結構不變）做逐項審核回覆，指出我已檢查到的狀態、假設、缺口、風險，以及一個可執行的實作細節/檔案清單和命名建議（以最小改動符合專案慣例）。讀取與搜尋步驟已完成，下面直接報告結果與建議。

總結（結論先行）
整體方向合適：把 Java 的三個主要功能（getJobFit、getFavoriteJob、updateJobFavorite）翻寫到 api_job 模組是合理的；也應該新增 components/e104/api/apply 作為 applyApi wrapper，符合現有 components/e104/api 的實作風格。
但有兩個重要缺口需要你確認或補給資訊，否則無法完成等價翻寫：
Python 專案裡沒有發現等價的 jobFitHandler（計算「履歷符合度」的邏輯）。Java 使用 JobFitHandler 做大量邏輯與 cache。要忠實還原，有兩個選項：a) 將 Java 的 jobFitHandler 邏輯（與其依賴）移植到 Python（工作量大），或 b) 新增一個外部 API wrapper 呼叫現有 Java service（較小改動）。你要選哪個？
applyApiService（jobsCheckApplicable）的 wrapper 在 Python 專案目前沒有；你要求要新增，這部分沒有障礙，我可以新增 components/e104/api/apply wrapper 來呼叫外部 API（需知道實際 endpoint 或依照既有 APIM wrapper 的配置）。
對回應 model 的要求可滿足：外層使用專案現有的 SuccessModel/ApiOutputModel 包裝；內層資料保留 Java 的結構（直接回傳從 DB 的 resume_fit_json 反序列化為 dict 或用 Pydantic model 映射），兩者都可以達成。我建議在初期直接保留內層為 dict（最少改動且保留原始結構），日後如需更嚴格型別再建立 Pydantic JobFitModel。
我檢查到的現況（關鍵證據）
Java side:
JobFitServiceImpl 包含 getJobFit, getFavoriteJob, updateJobFavorite。updateJobFavorite 與 getFavoriteJob 都會呼叫 jobFitHandler.getJobFitForLogin 與 applyApiService.jobsCheckApplicable。
jobFitHandler 與 JobFitModel 在 Java codebase 中非常完整（有 cache、組裝 skill fit、NCC/DTT 等邏輯）。
Python side (你的 repo):
models.py 已有 NabiJobFavorite（對應 DB table）。
actions.py, views.py, serializers.py 已存在某些職缺功能（recommend, saved jobs），並使用 JobOn 與 get_user_idno_with_cache。但沒有 jobFitHandler 等等價邏輯。
現有 components.e104.api 目錄下有許多 APIM wrapper 的範例（APIM pattern 存在），可參考來建立 components/e104/api/apply wrapper。
具體需求/缺口說明（須你決定）
jobFitHandler 的處理（必須決定）：
選項 A（建議短期）：新增一個外部 job-fit wrapper（例如 api.py）呼叫 Java 的 job-fit service（若公司已有該 service）。這最省力、風險低。
選項 B（較長期）：把 Java JobFitHandler 的邏輯完整移植成 Python（需翻譯大量業務邏輯、cache、能力匹配等），工作量大且需 extensive testing。
我目前在 repo 沒有找到等價的 Python job fit handler，請告知你偏好 A 或 B，或給我要呼叫的 job-fit API endpoint（若選 A）。
apply API wrapper：
我會新增 api.py（或 components/e104/api/apply/apply_api.py），並實作 class ApplyAPI(APIM) 與 method jobs_check_applicable(idno: int|None, jobnos: List[int]) -> List[dict]。需要外部 API path 與權鑰或採用既有 APIM 設定方式（若已有 conventions，我會直接複製 pattern）。
回應 model：
外層用 SuccessModel[...]（現有 pattern），內層暫以 dict（從 resume_fit_json decode 成字典）回傳以保留 Java 內部結構。若要嚴格 Pydantic mapping，需提供或同意要實作的 JobFit 欄位清單。
實作計畫（最小改動 + 符合專案慣例）
下面列出我要做的檔案/函式變更（請確認 job-fit 處理選項）。

A. serializers.py (新增 input model & outputs)

新增 GetFavoriteJobInModel(OffsetPageInModel)：
fields: pid: int, recFrom: Optional[int] or string?（Java 用字串，但 Python 專案偏用 int）；為最小改動建議維持 recFrom: int = Field(default=1)、requestLength: int = Field(default=10)。
新增 UpdateJobFavoriteInModel：
pid: int, jobno: int, favoriteState: int (0/1)
對 JobFit 的內層：暫不新增嚴格 Pydantic model，內層維持 dict。若要逐欄型別化，我會再建立 JobFitModel。
B. actions.py（主要新增）

函式命名（最小改動但 Python 慣例）：
Java getJobFit -> Python get_job_fit（actions 層），views route wrapper 名稱可保留 /getJobFit/{jobno} 路徑（專案中路徑命名不是完全 snake_case）。
Java getFavoriteJob -> Python get_favorite_job
Java updateJobFavorite -> Python update_job_favorite
注入 DB 與 decorators：
get_favorite_job : @inject_db(DBName.READ_ONLY) (或 READ_ONLY for queries)，@log_func_args
update_job_favorite : @inject_db(DBName.DEFAULT) + 如果有 @transactions 裝飾器應套上
行為 mapping：
totalRows: db.query(NabiJobFavorite).filter(NabiJobFavorite.pid == pid).count()
page query: query.order_by(NabiJobFavorite.id).offset(offset).limit(limit).all()
transferJobFitModel: decode favorite.resume_fit_json -> dict, collect jobno list, call JobOn().get_jobs_by_joblist(jobno_list) -> exist set, set offline accordingly, if offline changed -> DB update: session.query(...).filter(...).update({"offline": new_offline})
checkJobApplicable: use apply API wrapper to get applicable list and set isAlreadyApplied flag in each job dict
update_job_favorite: check job exists via JobOn, query existing favorites, if favoriteState==0: delete rows; if favoriteState==1: if no existing -> get idno via get_user_idno_with_cache and obtain job fit via chosen job-fit method -> create new NabiJobFavorite with resume_fit_json=json.dumps(job_fit_dict) and insert; wrap duplicate key exception handling (SQLAlchemy IntegrityError -> ignore).
錯誤處理：用 components 的 exceptions pattern；把 validation errors a la ParamValidateUtil 轉為 Pydantic validation + explicit checks.
C. views.py（新增路由）

新增 POST /getFavoriteJob，body: GetFavoriteJobInModel，optional query actor_id（跟 Java 相同），回傳 [SuccessModel[List[dict]]](http://vscodecontentref/36) 或 [SuccessModel[OffsetPageOutModel[dict]]](http://vscodecontentref/37)（依 Java meta 結構）。
新增 POST /updateJobFavorite，body: UpdateJobFavoriteInModel
新增 GET /getJobFit/{jobno} 已有類似 endpoint 在 Java; Python 端可保持 route /getJobFit/{jobno}，views wrapper 調用 actions.get_job_fit.
D. components/e104/api/apply (新增)

建檔： api.py
類似其他 APIM wrappers，class ApplyAPI(APIM) 或 ApplyService，提供:
def jobs_check_applicable(self, idno: Optional[int], jobnos: List[int]) -> List[dict]:
returns list of dicts like Java ApplyApiApplicable (fields: jobno, applicableStatus, ...)
再建立一個簡單 actions helper actions.py（如果需要）或直接在 components.e104.api.apply.api 用 import。
E. 其他

logging：在重要步驟（insert/delete/update/offline變更）加 logger。
重試或忽略 DuplicateKey：SQLAlchemy 的 IntegrityError 需捕捉並忽略，或用 ON CONFLICT DO NOTHING（如果使用 MySQL 可用 insert ignore）。
測試：新增 minimal unit tests 或 smoke test calling these actions with an in-memory/fixture DB row.
合約（contract） — 每個 API 的輸入/輸出/錯誤
get_job_fit

輸入: jobno (path param, int), pid (query, optional), version (default "1"), actor_id (optional)
輸出: SuccessModel[dict] where dict is original JobFit structure (same keys as Java JobFitModel)；meta fields: isFavorite, isAlreadyApplied 等（和 Java 保持一致）
錯誤模式: invalid jobno/pid -> 400 style response via existing components fastapi exception pattern
get_favorite_job

輸入: body JSON -> pid, recFrom (default 1), requestLength (default 10); optional actor_id query param
輸出: SuccessModel[List[dict]] (list of JobFit dicts) + meta keys totalRows, recFrom, resultRows, nextFrom
錯誤: invalid pid or invalid pagination -> return validation errors
update_job_favorite

輸入: pid, jobno, favoriteState (0/1)
輸出: SuccessModel[dict] e.g. {"result":"true"}
錯誤: invalid pid/jobno/favoriteState, job not exist -> appropriate 4xx errors
主要邊界 / 風險 / 邊緣情形（我會在實作時覆蓋）
resume_fit_json 解析失敗或為 null：要容錯（回傳空 dict 或 skip）
job 不存在（update favorite 時 favoriteState == 1）：Java 會回 NotExist error — 我會複製此行為
重複寫入 race condition：在 insert 時捕捉 IntegrityError（或 DuplicateKey），忽略如 Java
idno 取得失敗或為 null：Java 在登入/未登入會有不同 jobFit 流程；我會依 idno 是否存在分支處理（跟 Java 一致）
apply API 回傳格式異常：需把 wrapper 實作為堅固的 parser，並處理 empty 回傳
性能：transferJobFitModel 會呼叫 JobOn().get_jobs_by_joblist 一次（批次），這已在 Python 既有 get_saved_jobs 使用過，效能模式可重用
需要你確認的事項（請回覆）
jobFitHandler 的處理要採哪個策略？
A) 呼叫現成外部 job-fit service（我會新增 components/e104/api/job_fit wrapper） — 我需要該服務的 endpoint 或可參考的 APIM 設定
B) 移植 Java 的 JobFitHandler 到 Python（工作量大，需同意並分配時間）
apply API 外部 endpoint/授權設定（若有內部 APIM 配置，請提供或允許我參考其他 APIM wrapper 的 config）
內層資料是否允許直接以 dict（從 resume_fit_json load）回傳？或你要我先建立 Pydantic JobFitModel（需要定義所有欄位）？
下一步（我準備執行）
當你回覆以上三個確認（或選項）後，我會：
先實作 api.py wrapper（依既有 APIM pattern）。
在 serializers.py 新增 input models。
在 actions.py 新增 get_favorite_job, update_job_favorite, get_job_fit（以最小改動命名：get_favorite_job, update_job_favorite, get_job_fit），加入 @inject_db 與 @log_func_args。
在 views.py 新增對應 route wrappers（使用現有 ApiOutputModel.serialize_success 風格）。
跑靜態檢查 / 簡單 smoke test（驗證 import 與語法、DB query 基本流程），回報結果與任何阻礙（例如需要 job-fit service endpoint）。
若 job-fit 選 A（呼叫外部 service），在 actions 中呼叫該 wrapper 以產生 resume_fit_json。
請回覆你對上面三個須確認項（特別第 1 項 jobFit 策略與第 3 項內層是否用 dict）的選擇，我就開始實作並在完成初步實作後回報修改檔案清單與測試結果。

# Log
========================================================